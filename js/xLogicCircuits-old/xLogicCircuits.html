<!DOCTYPE html>
<!--
    Web page written by David Eck (https://math.hws.edu/eck/index.html)
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.
    
    This page implements a simulator for simple logic circuits made of
    AND, OR, and NOT gates.
    
    The original xLogicCircuits program was written in about 1993 in Macintosh Object
    Pascal and was translated into a Java applet in about 1997.  This JavaScript
    version is a 2023 translation of the Java applet, and its heritage is
    responsible for some of the code not following the usual JavaScript conventions.
    (Some of the code is a little strange from the JavaScript perspecitve.)
-->
<head>
<title>xLogicCircuits</title>
<style>
    html, body {
        padding: 0;
        margin: 0;
        background-color: #CCCCCC;
    }
    #content {
        padding: 10px;
        margin: 10px auto;
        width: 806px;
        border: 2px solid black;
        border-left: 2px solid black;
        background-color: #EEEEFF;
    }
    #circuit {
        background-color: white;
        display: block;
    }
    #overlay {
        position: absolute;
        z-index: 10;
        left: 0;
        top: 0;
        background-color: transparent;
        display: none;
    }
    #canvasholder {
        border: 2px solid black;
        margin: 0;
        padding: 0;
    }
    #scroller {
        width: 100px;
        height: 500px;
        border-top: 2px solid black;
        border-bottom: 2px solid black;
        border-left: 2px solid black;
        margin: 0;
        padding: 0;
        overflow-y: auto;
        overflow-x: hidden;
        background-color: white;
        direction: rtl;
    }
</style>

<script src="CircuitItem.js"></script>

<script>
   
//"use strict";
    
let canvas, graphics;
let OSC, OSG; // overlay canvas and graphics
let currentCircuit, circuitStack, currentCircuitIndex;
let untitledCt = 0;
let scroller, scrollItems;
let message;
let resizeBox = null;
let selectedItem = null;
let selectedItemInScroller;
let addTackWhileDrawing = null;
let addTackWileDrawingTimer = null;
let running = false;
let runSpeed = 0;
let runCountdown;
let loading = false;
let undoItems = [];
let redoStartIndex = 0;
const UNDO_MAX = 50;
let newBtn, clearBtn, saveBtn, deleteBtn;
let undoBtn, redoBtn, iconifyBtn, deiconifyBtn, shrinkBtn, enlargeBtn;
let titleInput;

function setMessage(msg = null) {
   message.innerHTML = msg === null? "&nbsp;" : msg;
}

class ScrollItem {

   constructor(circuitItem, name=null, standardItemNum=-1) {
       this.item = circuitItem;
       this.canvas = document.createElement("canvas");
       this.canvas.width = 100;
       this.canvas.height = 100;
       this.canvas.style.display = "block";
       this.canvas.style.direction = "ltr";
       this.canvas.owner = this;
       this.item.owner = this;
       this.graphics = this.canvas.getContext("2d");
       this.graphics.lineWidth = 2;
       this.name = name;
       this.standardItemNum = standardItemNum;
       if (standardItemNum >= 0 && standardItemNum < 3) {
          this.currentGate = 0;
          this.facing = [circuitItem];
          for (let i = 1; i < 4; i++)
             this.facing.push(new Gate(standardItemNum,i));
          if (standardItemNum === Gate.NOTGATE) {
              this.facing[0].reshape(30,35,40,30);
              this.facing[1].reshape(35,30,30,40);
              this.facing[2].reshape(30,35,40,30);
              this.facing[3].reshape(35,30,30,40);
          }
          else {
              this.facing[0].reshape(30,32,40,35);
              this.facing[1].reshape(32,30,35,40);
              this.facing[2].reshape(30,32,40,35);
              this.facing[3].reshape(32,30,35,40);
          }
       }
       else if (standardItemNum === 3 || standardItemNum === 4)
            circuitItem.reshape(50-7.5,50-7.5,18,15);
       else if (standardItemNum === 5)
            circuitItem.reshape(50-3.5,50-3.5,7,7);
       this.draw();
       this.canvas.onmousedown = function(evt) { evt.target.owner.doMouseDown(evt); };
       if (this.item instanceof Circuit)
          this.canvas.ondblclick = function(evt) { selectItem(evt.target.owner.item, true); doDeiconify(); };
       scroller.appendChild(this.canvas);
   }
       
   draw() {
      if (this.item.selected)
          this.graphics.fillStyle = "#F0F0F0";
      else
          this.graphics.fillStyle = "white";
      this.graphics.fillRect(0,0,100,100);
      this.item.draw(this.graphics);
      this.graphics.fillStyle = "black";
      this.graphics.fillRect(0,98,100,2);
      if (this.name !== null) {
          this.graphics.fillStyle = "blue";
          this.graphics.font = "12px serif";
          this.graphics.fillText(this.name,25,93);
      }
      if (this.standardItemNum >= 0 && this.standardItemNum < 3) {
          this.graphics.strokeStyle = "red";
          this.graphics.beginPath();
          this.graphics.arc(80,15,10,0,5*Math.PI/3);
          this.graphics.moveTo(84,19);
          this.graphics.lineTo(90,15);
          this.graphics.lineTo(94,21);
          this.graphics.stroke();
      }
   }
   
   doMouseDown(evt) {
       if (loading)
          return;
       if (!this.item.selected)  
          selectItem(null);
       setMessage();
       let r = this.canvas.getBoundingClientRect();
       let x = evt.clientX - r.left;
       let y = evt.clientY - r.top;
       if (this.standardItemNum >= 0 && this.standardItemNum < 3 && x > 68 && y < 27) { // rotate the gate
           this.currentGate++;
           if (this.currentGate > 3)
               this.currentGate = 0;
           this.item = this.facing[this.currentGate];
           this.draw();
           return;
       }
       let box = this.item.boundingBox;
       if (x > box.x - 5 && y > box.y - 5 && x < box.x + box.width + 5 && x < box.y + box.height + 5) {
           dragOntoCircuit(this.item.copy(),evt.clientX,evt.clientY,this.item);
           return;
       }
       if (this.item instanceof Circuit)
          selectItem(this.item,true);
   }

} // end class ScrollItem


function dragOntoCircuit(item,clientX,clientY,itemInScroller) {
    let startedDrag = false;
    let inCircuit = false;
    item.selected = false;
    document.addEventListener("mousemove",doMouseMove,false);
    document.addEventListener("mouseup",doMouseUp,false);
    let r = canvas.getBoundingClientRect();
    let start_x = clientX - r.left;
    let start_y = clientY - r.top;
    let bounds = new FloatRect(102,0,canvas.width,canvas.height);
    function doMouseMove(evt) { 
        if (!startedDrag) {
           let r = canvas.getBoundingClientRect();
           let x = evt.clientX - r.left;
           let y = evt.clientY - r.top;
           if (Math.abs(start_x - x) < 3 && Math.abs(start_y -y) < 3)
              return;
           startedDrag = true;
           selectItem(null);
           OSG.clearRect(0,0,OSC.width,OSC.height);
           OSC.style.display = "block";
        }
        let r = OSC.getBoundingClientRect();
        let x = evt.clientX - r.left;
        let y = evt.clientY - r.top;
        if ( x > 122 || (x > 102 && item instanceof CircuitIONub))
            inCircuit = true;
        snap(x,y);
    }
    function doMouseUp(evt) {
        OSC.style.display = "none";
        document.removeEventListener("mousemove",doMouseMove,false);
        document.removeEventListener("mouseup",doMouseUp,false);
        if (inCircuit) {
            item.move(item.boundingBox.x - 102, item.boundingBox.y);
            currentCircuit.addItem(item);
            selectItem(item);
            addUndoItem({name: "Add Item", item: item, container: currentCircuit});
        }
        else if ((itemInScroller instanceof Circuit))
           selectItem(itemInScroller,true);
    }
    function snap(x,y) {
        if (inCircuit)
           item.dragTo(x-item.boundingBox.width/2,y-item.boundingBox.height/2,bounds);
        else {
            if (x < 0)
               x = 0;
            if (y < 0)
               y = 0;
            else if (y > OSC.height)
               y = OSC.height;
            item.move(x-item.boundingBox.width/2,y-item.boundingBox.height/2);
        }
        OSG.clearRect(0,0,OSC.width,OSC.height);
        item.draw(OSG);
    }
}

function doMouseOnCircuit(evt) { 
   if (loading)
      return;
   setMessage();
   let r = canvas.getBoundingClientRect();
   let x = evt.clientX - r.left;
   let y = evt.clientY - r.top;
   if (resizeBox !== null && doResize(evt))
      return;
   if (running && evt.button === 0) {
      for (let i = currentCircuit.inputs.size() - 1; i >= 0; i--) {
         let input = currentCircuit.inputs.elementAt(i);
         if (input.hit(x,y)) {
             input.on = !input.on;
             input.drawCenter(graphics);
             break;
         }
      }
   }
   if (!(evt.shiftKey || evt.button === 1)) {
      let lineSource = currentCircuit.itemHitForLineSource(x,y);
      if (lineSource !== null) {
          doDrawLine(lineSource,evt,x,y);
          return;
      }
   }
   for (let i = currentCircuit.items.size() - 1; i >= 0; i--) { 
       if (currentCircuit.items.elementAt(i).hit(x,y)) {
           doHitItem(currentCircuit.items.elementAt(i),evt,x,y);
           return;
       }
   }
   for (let i = currentCircuit.inputs.size() - 1; i >= 0; i--) {
       if (currentCircuit.inputs.elementAt(i).hit(x,y)) {
           doHitItem(currentCircuit.inputs.elementAt(i),evt,x,y);
           return;
       }
   }
   for (let i = currentCircuit.outputs.size() - 1; i >= 0; i--) { 
       if (currentCircuit.outputs.elementAt(i).hit(x,y)) {
           doHitItem(currentCircuit.outputs.elementAt(i),evt,x,y);
           return;
       }
   }
   for (let i = currentCircuit.lines.size() - 1; i >= 0; i--) { 
       if (currentCircuit.lines.elementAt(i).hit(x,y)) { 
           selectItem(currentCircuit.lines.elementAt(i));
           return;
       }
   }
   selectItem(null);
}
function doHitItem(item,evt,x,y) {
   if (!(evt.shiftKey || evt.button === 1)) {
       selectItem(item);
       return;
   }
   selectItem(null);
   let offset_x = x - item.boundingBox.x;
   let offset_y = y - item.boundingBox.y;
   let canvasBounds = new FloatRect(0,0,canvas.width,canvas.height);
   let startPosition = [item.boundingBox.x, item.boundingBox.y];
   document.addEventListener("mousemove",doMouseMove,false);
   document.addEventListener("mouseup",doMouseUp,false);
   function doMouseMove(evt) {
      let r = canvas.getBoundingClientRect();
      let a = evt.clientX - r.left - offset_x;
      let b = evt.clientY - r.top - offset_y;
      item.dragTo(a,b,canvasBounds);
      drawCurrentCircuit();
   }
   function doMouseUp(evt) {
      document.removeEventListener("mousemove",doMouseMove,false);
      document.removeEventListener("mouseup",doMouseUp,false);
      let endPosition = [item.boundingBox.x, item.boundingBox.y];
      selectItem(item);
      if (startPosition[0] !== endPosition[0] || startPosition[1] !== endPosition[1])
         addUndoItem({name: "Move Item", item: item, startPosition: startPosition, endPosition: endPosition, bounds: canvasBounds});
   }
}
function doResize(evt) {
   const UL = 0, UR = 1, LL = 2, LR = 3;  // vertices
   const minWidth = 20, minHeight = 20;
   const legalRect = new FloatRect(20,20,canvas.width-40,canvas.height-40);
   let startbox = [resizeBox.x, resizeBox.y, resizeBox.width, resizeBox.height];
   let x4, y4, vertexHit, offset_x, offset_y;
   let r = canvas.getBoundingClientRect();
   let a = evt.clientX - r.left;
   let b = evt.clientY - r.top;
   x4 = resizeBox.x + resizeBox.width - 5;
   y4 = resizeBox.y + resizeBox.height - 5;
   if (a >= resizeBox.x-1 && a < resizeBox.x + 6) {
      if (b >= resizeBox.y-1 && b < resizeBox.y + 6) {
         vertexHit = UL;
         offset_x = resizeBox.x-a;
         offset_y = resizeBox.y-b;
      }
      else if (b >= y4-1 && b < y4 + 6) {
         vertexHit = LL;
         offset_x = resizeBox.x-a;
         offset_y = resizeBox.y+resizeBox.height-b;
      }
      else
         return false;
   }
   else if (a >= x4-1 && a < x4 + 6) {
      if (b >= resizeBox.y-1 && b < resizeBox.y + 6) {
         vertexHit = UR;
         offset_x = resizeBox.x+resizeBox.width-a;
         offset_y = resizeBox.y-b;
      }
      else if (b >= y4-1 && b < y4 + 6) {
         vertexHit = LR;
         offset_x = resizeBox.x+resizeBox.width-a;
         offset_y = resizeBox.y+resizeBox.height-b;
      }
      else
         return false;
   }
   else
      return false;
   canvas.addEventListener("mousemove",doMouseMove,false);
   document.addEventListener("mouseup",doMouseUp,false);
   return true;
   function doMouseMove(evt) {
      let r = canvas.getBoundingClientRect();
      let a = evt.clientX - r.left;
      let b = evt.clientY - r.top;
      a += offset_x;
      b += offset_y;
      if (legalRect != null) {
         if (a < legalRect.x)
            a = legalRect.x;
         else if (a > legalRect.x+legalRect.width)
            a = legalRect.x+legalRect.width;
         if (b < legalRect.y)
            b = legalRect.y;
         else if (b > legalRect.y+legalRect.height)
            b = legalRect.y+legalRect.height;
      }
      switch (vertexHit) {
         case UL:
           if (a >= resizeBox.x+resizeBox.width-minWidth)
              a = resizeBox.x+resizeBox.width-minWidth;
           if (b >= resizeBox.y+resizeBox.height-minHeight)
              b = resizeBox.y+resizeBox.height-minHeight;
           reshape(a,b,resizeBox.width+resizeBox.x-a,resizeBox.height+resizeBox.y-b);
           break;
         case LL:
           if (a >= resizeBox.x+resizeBox.width-minWidth)
              a = resizeBox.x+resizeBox.width-minWidth;
           if (b < resizeBox.y+minHeight)
              b = resizeBox.y+minHeight;
           reshape(a,resizeBox.y,resizeBox.width+resizeBox.x-a,b-resizeBox.y);
           break;
         case UR:
           if (a < resizeBox.x+minWidth)
              a = resizeBox.x+minWidth;
           if (b >= resizeBox.y+resizeBox.height-minHeight)
              b = resizeBox.y+resizeBox.height-minHeight;
           reshape(resizeBox.x,b,a-resizeBox.x,resizeBox.height+resizeBox.y-b);
           break;
         case LR:
           if (a < resizeBox.x+minWidth)
              a = resizeBox.x+minWidth;
           if (b < resizeBox.y+minHeight)
              b = resizeBox.y+minHeight;
           reshape(resizeBox.x,resizeBox.y,a-resizeBox.x,b-resizeBox.y);
           break;
      }
      last_x = resizeBox.x;
      last_y = resizeBox.y;      
   }
   function reshape(x,y,width,height) {
       resizeBox.x = x;
       resizeBox.y = y;
       resizeBox.width = width;
       resizeBox.height = height;
       selectedItem.reshape(resizeBox.x, resizeBox.y, resizeBox.width, resizeBox.height);
       drawCurrentCircuit();
   }
   function doMouseUp(evt) {
      canvas.removeEventListener("mousemove",doMouseMove,false);
      document.removeEventListener("mouseup",doMouseUp,false);
      let endbox = [resizeBox.x, resizeBox.y, resizeBox.width, resizeBox.height];
      if (startbox[0] !== endbox[0] ||startbox[2] !== endbox[2] ||startbox[3] !== endbox[3] ||startbox[4] !== endbox[4])
         addUndoItem({name: "Resize", startbox: startbox, endbox: endbox, item: selectedItem});
   }
}
function doDrawLine(sourceItem,evt,start_x,start_y) {
   let destinationItem = null;
   let source = sourceItem.getLineSource(start_x,start_y);
   if (source === null)
       return;
   let started = false;
   let destination;
   document.addEventListener("mousemove",doContinueLine,false);
   document.addEventListener("mouseup",doEndLine,false);
   function doContinueLine(evt) {
      let needsRefresh = false;
      let r = canvas.getBoundingClientRect();
      let x = evt.clientX - r.left;
      let y = evt.clientY - r.top;
      if (!started) {
         if (Math.abs(x - start_x) < 3 && Math.abs(y - start_y < 3))
            return;
         OSG.clearRect(0,0,OSC.width,OSC.height);
         OSC.style.display = "block";
         selectItem(null);
         sourceItem.selected = true;
         needsRefresh = true;
         started = true;
      }
      let newSource = sourceItem.getLineSource(x,y);
      if (newSource !== null)
         source = newSource;
      let newDestinationItem = currentCircuit.itemHitForLineDestination(x,y);
      if (newDestinationItem === sourceItem)
          newDestinationItem = null;
      if (newDestinationItem === null)
          destination = null;
      else {
          destination = newDestinationItem.getLineDestination(x,y);
          if (destination === null)
             newDestinationItem = null;
      }
      if (newDestinationItem === null) {
         if (destinationItem !== null) {
            destinationItem.selected = false;
            sourceItem.selected = true;
            needsRefresh = true;
         }
      }
      else if (newDestinationItem !== destinationItem) {
         if (destinationItem === null)
            sourceItem.selected = false;
         else
            destinationItem.selected = false;
         newDestinationItem.selected = true;
         needsRefresh = true;
      }
      destinationItem = newDestinationItem;
      OSG.clearRect(0,0,OSC.width,OSC.height);
      if (destinationItem === null) {
          OSG.beginPath();
          OSG.moveTo(102+source.connect_x,source.connect_y);
          OSG.lineTo(102+x,y);
          OSG.strokeStyle = "green";
          OSG.stroke();
      }
      else {
          OSG.beginPath();
          OSG.moveTo(102+source.connect_x,source.connect_y);
          OSG.lineTo(102+destination.connect_x,destination.connect_y);
          OSG.lineWidth = 6;
          OSG.strokeStyle = "white";
          OSG.stroke();
          OSG.lineWidth = 2;
          OSG.strokeStyle = "green";
          OSG.stroke();
      }
      if (needsRefresh)
         drawCurrentCircuit();
   }
   function doEndLine(evt) {
      document.removeEventListener("mousemove",doContinueLine,false);
      document.removeEventListener("mouseup",doEndLine,false);
      if (!started) {
         OSC.style.display = "none";
         selectItem(sourceItem);
         return;
      }
      sourceItem.selected = false;
      if (destinationItem !== null) {
         OSC.style.display = "none";
         destinationItem.selected = false;
         let line = new Line(source,destination);
         currentCircuit.addItem(line);
         selectItem(line);
         addUndoItem({name: "Add Wire", item: line, container: currentCircuit});
      }
      else {
         OSC.addEventListener("mousedown",doAddTack,false);
         let r = canvas.getBoundingClientRect();
         let x = evt.clientX - r.left;
         let y = evt.clientY - r.top;
         addTackWhileDrawing = { x: x, y: y };
         addTackWileDrawingTimer = setTimeout(doFinish, 250);
      }
   }
   function doAddTack(evt) {
      OSC.removeEventListener("mousedown",doAddTack,false);
      OSC.style.display = "none";
      clearTimeout(addTackWileDrawingTimer);
      let r = canvas.getBoundingClientRect();
      let x = evt.clientX - r.left;
      let y = evt.clientY - r.top;
      if (Math.abs(x - addTackWhileDrawing.x) <= 2 &&
           Math.abs(y - addTackWhileDrawing.y) <= 2) {
         let tack = new Tack();
         tack.reshape(x - 3.5, y - 3.5, 7, 7);
         currentCircuit.addItem(tack);
         let line = new Line(source, tack);
         currentCircuit.addItem(line);
         selectItem(tack);
         addUndoItem({name: "Drop Tack", tack: tack, container: currentCircuit});
         drawCurrentCircuit();
         doDrawLine(tack,evt,x,y);
      }
      else {
         drawCurrentCircuit();
      }
   }
   function doFinish() { 
      OSC.removeEventListener("mousedown",doAddTack,false);
      OSC.style.display = "none";
      addTackWhileDrawing = null;
      addTackWileDrawingTimer = null;
      if (started)
         drawCurrentCircuit();
      else
         selectItem(sourceItem);
   }
}

function doCheckInputClick(evt) { 
   if (!running || evt.button !== 0)
      return;
   let r = canvas.getBoundingClientRect();
   let x = evt.clientX - r.left;
   let y = evt.clientY - r.top; 
   for (let i = 0; i < currentCircuit.inputs.size(); i++) {
      let input = currentCircuit.inputs.elementAt(i);
      if (input.hit(x,y)) {
         input.on = !input.on;
         input.drawCenter(graphics);
         return;
      }
   }
}

function doDoubleClick(evt) {
   if (loading)
      return;
   setMessage();
   let r = canvas.getBoundingClientRect();
   let x = evt.clientX - r.left;
   let y = evt.clientY - r.top;
   for (let i = 0; i < currentCircuit.items.size(); i++) {
      let item = currentCircuit.items.elementAt(i);
      if ((item instanceof Circuit) && item.hit(x,y)) {
         selectItem(item);
         doEnlarge();
      }
   }
   for (let i = 0; i < currentCircuit.lines.size(); i++) { 
      let line = currentCircuit.lines.elementAt(i);
      if (line.hit(x,y)) { // add a tack
         let tack = new Tack();
         tack.reshape(x-3.5,y-3.5,7,7);
         let source = line.source;
         let dest = line.destination;
         line.delete(currentCircuit);
         let line1 = new Line(source,tack);
         let line2 = new Line(tack,dest);
         currentCircuit.lines.addElement(line1);
         currentCircuit.lines.addElement(line2);
         currentCircuit.items.addElement(tack);
         line1.on = line2.on = tack.on = line.on;
         selectItem(tack);
         addUndoItem({name: "Insert Tack in Wire", tack: tack, line: line, container: currentCircuit});
         return;
      }
   }
}

function drawCurrentCircuit() {
    graphics.fillStyle = "#EEEAC8";
    graphics.fillRect(0,0,canvas.width,canvas.height);
    graphics.strokeStyle = "#0000AA";
    graphics.beginPath();
    graphics.moveTo(7.5,7.5);
    graphics.lineTo(canvas.width-7.5,7.5);
    graphics.lineTo(canvas.width-7.5,canvas.height-7.5);
    graphics.lineTo(7.5,canvas.height-7.5);
    graphics.closePath();
    graphics.lineWidth = 1;
    graphics.stroke();
    graphics.lineWidth = 2;
    currentCircuit.draw(graphics);
    if (resizeBox !== null) {
         let x4 = resizeBox.x + resizeBox.width - 5;
         let y4 = resizeBox.y + resizeBox.height - 5;
         graphics.strokeStyle = "gray";
         graphics.fillStyle = "black";
         graphics.strokeRect(resizeBox.x,resizeBox.y,resizeBox.width,resizeBox.height);
         graphics.fillRect(resizeBox.x,resizeBox.y,6,6);
         graphics.fillRect(resizeBox.x,y4,6,6);
         graphics.fillRect(x4,resizeBox.y,6,6);
         graphics.fillRect(x4,y4,6,6);
    }
}

function selectItem(item, inScroller = false) {
   if (item === selectedItem)
      return;
   let needDraw = false;
   if (selectedItem !== null) {
      selectedItem.selected = false;
      if (selectedItemInScroller)
         selectedItem.owner.draw();
      else
          needDraw = true;
      resizeBox = null;
      selectedItemInScroller = false;
   }
   selectedItem = item;
   selectedItemInScroller = inScroller;
   if (item !== null) {
      item.selected = true;
      if (inScroller) {
         selectedItem.owner.draw();
         let scrollPosition = 100*scrollItems.indexOf(selectedItem.owner);
         if (scrollPosition >= 0) { // should always happen
            if (scroller.scrollTop > scrollPosition)
               scroller.scrollTop = scrollPosition;
            else if (scroller.scrollTop < scrollPosition - 400)
               scroller.scrollTop = scrollPosition - 400;
         }
      }
      else {
         if (item instanceof Gate || item instanceof Circuit)
            resizeBox = new FloatRect(item.boundingBox.x, item.boundingBox.y, item.boundingBox.width, item.boundingBox.height);
         needDraw = true;
      }
   }
   if (needDraw)
      drawCurrentCircuit();
   setEnabledStates();
}

function setEnabledStates() {
   let empty = currentCircuit.items.size() === 0 && currentCircuit.inputs.size() === 0 && currentCircuit.outputs.size() === 0;
   clearBtn.disabled = currentCircuitIndex === 0 ? empty : currentCircuit.items.size() === 0;
   newBtn.disabled = empty && scrollItems.length === 6;
   saveBtn.disabled =  empty && currentCircuitIndex === 0;
   deleteBtn.disabled = selectedItem === null;
   iconifyBtn.disabled = empty || currentCircuitIndex > 0;
   deiconifyBtn.disabled = selectedItem === null || !selectedItemInScroller;
   shrinkBtn.disabled = currentCircuitIndex === 0;
   enlargeBtn.disabled = selectedItem === null || selectedItemInScroller || !(selectedItem instanceof Circuit);
}

function adjustToWindowSize() {
    let canvasRect = document.getElementById("scroller").getBoundingClientRect(); 
    OSC.style.left = (canvasRect.left+window.scrollX+2) + "px";
    OSC.style.top = (canvasRect.top+window.scrollY+2) + "px";
}

function doClear() {
   if (loading)
      return;
   powerOff();
   setMessage();
   if (selectedItem !== null) {
      if (selectedItemInScroller)
         selectItem(null);
      else {
         selectedItem.selected = false;
         selectedItem = null;
         resizeBox = null;
         selectedItemInScroller = false;
      }
   } 
   if (currentCircuitIndex === 0) {
      circuitStack = [new Circuit()];
      addUndoItem({name: "Clear",  newstack: circuitStack, circuit: currentCircuit, title: titleInput.value});
      currentCircuit = circuitStack[0];
   }
   else {
      addUndoItem({name: "Clear Subcircuit", items: currentCircuit.items,
                       lines: currentCircuit.lines, title: titleInput.value});
      for (let i = 0; i < currentCircuit.inputs.size(); i++) {
         currentCircuit.inputs.elementAt(i).destination = new Vector();
      }
      for (let i = 0; i < currentCircuit.outputs.size(); i++) {
         currentCircuit.outputs.elementAt(i).source = null;
      }
      currentCircuit.items = new Vector();
      currentCircuit.lines = new Vector();
   }
   drawCurrentCircuit();
   document.getElementById("powercheck").checked = false;
   setEnabledStates();
}

function doNew() {
   if (loading)
      return;
   setMessage();
   selectItem(null);
   powerOff();
   let stack = circuitStack;
   currentCircuit = new Circuit();
   circuitStack = [currentCircuit];
   currentCircuitIndex = 0;
   drawCurrentCircuit();
   let scrolls = scrollItems.splice(6,10000);
   for (let i = scrolls.length-1; i >= 0; i--)
      scroller.removeChild(scrolls[i].canvas);
   scroller.scrollTop = 0;
   let newtitle = "Untitled " + (++untitledCt);
   addUndoItem({name: "New", stack: stack, scrollitems: scrolls,
               oldtitle: titleInput.value, newstack: circuitStack, newtitle: newtitle});
   titleInput.value = newtitle;
   setEnabledStates();
}


function doDelete() {
   if (selectedItem === null)
      return;
   setMessage();
   if (selectedItemInScroller) {
      let pos = scrollItems.indexOf(selectedItem.owner);
      scrollItems.splice(pos,1);
      scroller.removeChild(selectedItem.owner.canvas);
      addUndoItem({ name: "Delete Scroll Icon", item: selectedItem.owner, position: pos });
   }
   else {
      selectedItem.delete(currentCircuit);
      addUndoItem( { name: "Delete", item: selectedItem, owner: currentCircuit } );
   }
   selectItem(null);
}

function doIconify() {
   if (loading)
      return;
   setMessage();
   if (currentCircuitIndex > 0 ||
          (currentCircuit.items.size() === 0 && currentCircuit.inputs.size() === 0 && currentCircuit.outputs.size() === 0))
      return;
   if (selectedItem !== null && !selectedItemInScroller) {
       selectedItem.selected = false;
       selectedItem = null;
       resizeBox = null;
   }
   let oldCircuit = currentCircuit;
   oldCircuit.iconify(20,10,70,80);
   oldCircuit.name = titleInput.value.trim();
   if (oldCircuit.name === "")
       oldCircuit.name = "Untitled " + (++untitledCt);
   currentCircuit = new Circuit();
   circuitStack = [currentCircuit];
   currentCircuitIndex = 0;
   drawCurrentCircuit();
   titleInput.value = "Untitled " + (++untitledCt);
   scrollItems.push(new ScrollItem(oldCircuit));
   selectItem(oldCircuit, true);
   addUndoItem({name: "Iconify", scrollitem: scrollItems[scrollItems.length-1], newtitle: titleInput.value, newstack: circuitStack});
}
function doDeiconify() {
   if (selectedItem === null || !selectedItemInScroller)
      return;
   setMessage();
   let stack = circuitStack;
   let oldCircuit = circuitStack[0];
   let oldtitle = titleInput.value;
   if (currentCircuitIndex === 0) {
       currentCircuit.name = titleInput.value.trim();
       if (currentCircuit.name === "")
           currentCircuit.name = "Untitled " + (++untitledCt);
   }
   else {
       for (let i = currentCircuitIndex; i > 0; i--) {
          let r = circuitStack[i].boundingBoxInContainer.getIntRect();
          circuitStack[i].iconify(r.x,r.y,r.width,r.height);
       }
   }
   let oldscrollitem = selectedItem.owner;
   let pos = scrollItems.indexOf(oldscrollitem);
   scrollItems.splice(pos,1);
   scroller.removeChild(selectedItem.owner.canvas);
   currentCircuit = selectedItem;
   circuitStack = [currentCircuit];
   currentCircuitIndex = 0;
   currentCircuit.selected = false;
   selectedItem = null;
   resizeBox = null;
   setEnabledStates();
   selectedItemInScroller = false;
   currentCircuit.deiconify(0,0,canvas.width,canvas.height,null);
   titleInput.value = currentCircuit.name;
   let newscrollitem = null;
   if (oldCircuit.items.size() > 0 || oldCircuit.inputs.size() > 0 || oldCircuit.outputs.size() > 0) {
      oldCircuit.iconify(20,10,70,80);
      scrollItems.push(new ScrollItem(oldCircuit));
      newscrollitem = scrollItems[scrollItems.length-1];
   }
   drawCurrentCircuit();
   addUndoItem({name:"Deiconify", position: pos, oldstack: stack,
                   oldscrollitem: oldscrollitem, oldtitle: oldtitle, newscrollitem: newscrollitem});
}

function doShrink() {
   if (currentCircuitIndex === 0)
       return;
   setMessage();
   let oldCircuit = currentCircuit;
   let r = currentCircuit.boundingBoxInContainer;
   currentCircuit.iconify(r.x, r.y, r.width, r.height);
   circuitStack.pop();
   currentCircuitIndex--;
   currentCircuit = circuitStack[circuitStack.length - 1];
   if (selectedItem !== null && !selectedItemInScroller)
      selectedItem.selected = false;
   selectItem(oldCircuit);
   titleInput.value = currentCircuit.name;
   addUndoItem({name: "Shrink Circuit", item: oldCircuit});
}
function doEnlarge() {
   if (selectedItem === null || selectedItemInScroller || !(selectedItem instanceof Circuit))
      return;
   setMessage(); 
   if (currentCircuit.name === null) {
      let name = titleInput.value.trim();
      if (name === "")
          titleInput.value = name = "Untitled " + (++untitledCt);
      currentCircuit.name = name;
   } 
   selectedItem.deiconify(0,0,canvas.width,canvas.height,currentCircuit);
   circuitStack.push(selectedItem);
   currentCircuitIndex++;
   currentCircuit = selectedItem;
   selectedItem.selected = false;
   selectedItem = null;
   resizeBox = null;
   setEnabledStates();
   drawCurrentCircuit();
   titleInput.value = currentCircuit.name;
   addUndoItem({name: "Enlarge Subcircuit", item: currentCircuit});
}

function runStep() {  
   if (!running)
      return;
   if (runCountdown > 0)
      runCountdown--;
   if (runCountdown === 0) {
      let changed = currentCircuit.computeTopLevel();
      if (runSpeed === 0)
          changed = changed || currentCircuit.computeTopLevel();
      if (changed)
          drawCurrentCircuit(); 
      runCountdown = runSpeed === 0? 0 : runSpeed === 1? 3 : 30;
   }
   requestAnimationFrame(runStep);
}
function doPower() {
   if (loading) {
      document.getElementById("powercheck").checked = false;
      return;
   }
   setMessage();
   let newRunning = document.getElementById("powercheck").checked;
   if (newRunning === running)
      return;
   running = newRunning;
   if (running) {
      runCountdown = 0;
      requestAnimationFrame(runStep);
   }
   else {
      currentCircuit.powerOff();
      drawCurrentCircuit();
   }
}
function powerOff() {
   document.getElementById("powercheck").checked = false;
   doPower();
}
function doSpeed() {
   runSpeed = Number(document.getElementById("speedselect").value);
}

//------------ File handling -------------------------------

function setUpFileHandling() {
    if (window.showOpenFilePicker && FileSystemFileHandle && FileSystemFileHandle.prototype.getFile) {
        loadBtn.addEventListener("click",doLoad,false);
    }
    else {
        let chooser = document.createElement("input");
        chooser.type = "file";
        chooser.id = "chooseloadfile";
        chooser.style.display = "none";
        document.getElementById("content").appendChild(chooser);
        loadBtn.addEventListener("click",doBasicLoad,false);
    }
    if (window.showSaveFilePicker && FileSystemFileHandle && FileSystemFileHandle.prototype.createWritable) {
        saveBtn.addEventListener("click",doSave,false);  
    }
    else {
        saveBtn.addEventListener("click",doBasicSave,false);
    }
    function doBasicSave() {
        if (loading)
           return;
        selectItem(null);
        let content = circuitsToText(circuitStack,scrollItems);
        let blob = new Blob([content], {type: 'text/plain'});
        let link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        if (currentCircuitIndex === 0 && currentCircuit.name === null) {
           currentCircuit.name = titleInput.value.trim();
           if (currentCircuit.name === "")
              titleInput.value = currentCircuit.name = "Untitled " + (++untitledCt);
        }
        link.download = circuitStack[0].name + ".txt";
        link.click();
        URL.revokeObjectURL(link.href);
    }
    async function doSave() {
        if (loading)
           return;
        selectItem(null);
        let content = circuitsToText(circuitStack,scrollItems);
        let blob = new Blob([content], {type: 'text/plain'});
        if (currentCircuitIndex === 0 && currentCircuit.name === null) {
           currentCircuit.name = titleInput.value.trim();
           if (currentCircuit.name === "")
              titleInput.value = currentCircuit.name = "Untitled " + (++untitledCt);
        }
        let options = { suggestedName: circuitStack[0].name + ".txt" };
        try {
            let fileHandle = await window.showSaveFilePicker(options);
            let stream = await fileHandle.createWritable();
            await stream.write(blob);
            await stream.close();
            document.getElementById("status").innerHTML =  "xModels status: File has been saved.";
        }
        catch (e) {
            if (e.name !== "AbortError") {
                alert("An error occurred whlie trying to save the file (" + e + ")");
                document.getElementById("status").innerHTML =  "xModels status: Error while saving file.";
            }
        }
    }
    function doBasicLoad() {
        powerOff();
        selectItem(null);
        setMessage();
        let chooser = document.getElementById("chooseloadfile");
        chooser.value = "";
        document.getElementById("chooseloadfile").addEventListener("change",handleBasicFileLoad,false);
        chooser.click();
    }
    async function handleBasicFileLoad() {
       loadBtn.disabled = true;
       loading = true;
       try {
            let chooser = document.getElementById("chooseloadfile");
            chooser.removeEventListener("change",handleBasicFileLoad,false);
            if (chooser.files.length === 0)
               return;
            setMessage("Trying to load file " + chooser.files.name);
            if ( chooser.files[0].type && ! /^text/i.test(chooser.files[0].type))
                throw "Only text files can be loaded.";
            let text = await chooser.files[0].text();
            newCircuit(text);
            setMessage("Successfully loaded file " + chooser.files[0].name);
       }
       catch (e) {
           setMessage("File load failed (" + e + ")");
       }
       finally {
           loadBtn.disabled = false;
           loading = false;
           setEnabledStates();
       }
    }
    async function doLoad() {
       powerOff();
       selectItem(null);
       setMessage("Load file -- select a file or cancel!");
       loading = true;
       loadBtn.disabled = true;
       try {
           let files = await window.showOpenFilePicker();
           if (files.length === 0) {
              setMessage("File load canceled"); // (Can this happen?)
              return;
           }
           let fileData = await files[0].getFile();
           if ( fileData.type && ! /^text/i.test(fileData.type)) 
               throw "Only text files can be loaded.";
           let text = await fileData.text();
           newCircuit(text);
           setMessage("Successfully loaded file " + fileData.name);
       }
       catch (e) {
           if (e.name === "AbortError")
              setMessage("File load canceled");
           else
              setMessage("File load failed. (" + e + ")");
       }
       finally {
           loadBtn.disabled = false;
           loading = false;
           setEnabledStates();
       }
    }
}
function newCircuit(text,addundo=true) {
     powerOff();
     let circuits,scrolls;
     try {
        [circuits,scrolls] = textToCircuits(text);
     }
    catch (e) {
        throw "Error in file: " + e;
     }
     let oldStack = circuitStack;
     let oldTitle = titleInput.value;
     for (let i = 0; i < circuits.length; i++)
        circuits[i].reshape(0,0,canvas.width,canvas.height);
     circuitStack = circuits;
     currentCircuitIndex = circuitStack.length - 1;
     currentCircuit = circuitStack[currentCircuitIndex];
     titleInput.value = currentCircuit.name;
     let removedScrolls = scrollItems.splice(6,10000);
     for (let i = removedScrolls.length-1; i >= 0; i--)
        scroller.removeChild(removedScrolls[i].canvas);
     let addedScrolls = [];
     for (let i = 0; i < scrolls.length; i++) {
         scrolls[i].reshape(20,10,70,80);
         let item = new ScrollItem(scrolls[i]);
         addedScrolls.push(item);
         scrollItems.push(item);
     }
     drawCurrentCircuit();
     if (addundo) {
         addUndoItem({name: "Load Local File", removedscrollitems: removedScrolls,
                    newscrollitems: addedScrolls, oldstack: oldStack, newstack: circuitStack,
                    oldtitle: oldTitle});
     }
}

function textToCircuits(text) { // returns an array containing new circuitStack and scroll items
                                // can throw a string that contains an error message
   let pos = 0;
   if (getLine() !== "This is an xLogicCircuits data file." || getLine() != "DO NOT EDIT THIS FILE!")
      inputError("Input is not a legal xLogicCircuits file.");
   if (getLine() !== "File format version 1.0")
      inputError("File requires a newer version of xLogicCircuits.");
   return [getCircuitStack(),getScrollItems()];
   function inputError(msg = "Bad data found in file.") {
      throw msg;
   }
   function getCircuitStack() {
      let circuits = [];
      let ct = getInt();
      if (ct < 0)
         inputError();
      for (let i = 0; i < ct; i++) {
         let ch = getNonBlank();
         if (ch === '@') {
            if (i === 0)
               inputError();
            let pos = getInt();
            let parent = circuits[circuits.length-1];
            if (pos < 0 || pos >= parent.items.size())
               inputError();
            let cir = parent.items.elementAt(pos);
            if (! (cir instanceof Circuit) )
               inputError();
            cir.iconified = false;
            cir.boundingBoxInContainer = getFloatRect();
            cir.saveContainerWhileEnlarged = parent;
            circuits.push(cir);
         }
         else if (ch === '=') {
            if (i != 0)          // added later to prevent having more than one main circuit on the circuit stack
               inputError();
            let cir = getCircuit(null);
            cir.iconified = false;
            circuits.push(cir);
         }
         else
            inputError();
      }
      return circuits;
   }
   function getScrollItems() {
      let circuits = [];
      let ct = getInt();
      if (ct < 0)
         inputError();
      for (let i = 0; i < ct; i++)
         circuits.push(getCircuit(null));
      return circuits;
   }
   function getCircuit(parentLines) {
      let circuit = new Circuit();
      circuit.iconified = true;  // can be changed in getCircuitStack()
      circuit.name = getLine();
      circuit.boundingBox = getFloatRect();
      circuit.savedBoundingBox = getFloatRect();
      let itemCt = getInt();
      let lineCt = getInt();
      let inputCt = getInt();
      let outputCt = getInt();
      if (itemCt < 0 || lineCt < 0 || inputCt < 0 || outputCt < 0)
         inputError();
      let lines = new Array(lineCt);
      for (let i = 0; i < lineCt; i++)
         lines[i] = new Line(null,null);
      circuit.inputs = new Vector();
      for (let i = 0; i < inputCt; i++)
         circuit.inputs.addElement(getCircuitIONub(true,lines,parentLines));
      circuit.outputs = new Vector();
      for (let i = 0; i < outputCt; i++)
         circuit.outputs.addElement(getCircuitIONub(false,lines,parentLines));
      circuit.items = new Vector();
      for (let i = 0; i < itemCt; i++) {
         let code = getNonBlank();
         let item;
         if (code == 'T')
            item = getTack(lines);
         else if (code == '*')
            item = getCircuit(lines);
         else
            item = getGate(code,lines);
         circuit.items.addElement(item);
      }
      for (let i = 0; i < lineCt; i++)
         if (lines[i].source === null || lines[i].destination === null)
            inputError();
      circuit.lines = new Vector();
      for (let i = 0; i < lineCt; i++)
         circuit.lines.addElement(lines[i]);
      return circuit;
   }
   function getTack(lines)  {
      let tack = new Tack();
      tack.connect_x = getInt();
      tack.connect_y = getInt();
      tack.boundingBox = new FloatRect(tack.connect_x - 3.5, tack.connect_y - 3.5, 7, 7);
      tack.source = getSource(tack,lines);
      tack.destination = getDestination(tack,lines);
      return tack;
   }
   function getCircuitIONub(input, lines, parentLines)  {
      let ch = getNonBlank();
      if (input && ch != '<')
         inputError();
      else if (!input && ch != '>')
         inputError();
      let side = getInt();
      if (side < 0 || side > 3)
         inputError();
      let position = getFloat();
      if (position < 0 || position > 1)
         inputError();
      let nub = new CircuitIONub(side,position,input);
      if (input) {
         nub.source = getSource(nub,parentLines);
         nub.destination = getDestination(nub,lines);
      }
      else {
         nub.source = getSource(nub,lines);
         nub.destination = getDestination(nub,parentLines);
      }
      return nub;
   }
   function getGate(typeCode, lines)  {
      let gate = null;
      let facing = getInt();
      if (facing < 0 || facing > 3)
         inputError();
      if (typeCode === 'N')
         gate = new Gate(Gate.NOTGATE,facing);
      else if (typeCode === 'A')
         gate = new Gate(Gate.ANDGATE,facing);
      else if (typeCode === 'R')
         gate = new Gate(Gate.ORGATE,facing);
      else
         inputError();
      gate.boundingBox = getFloatRect();
      gate.in1.source = getSource(gate.in1,lines);
      if (typeCode != 'N')
         gate.in2.source = getSource(gate.in2,lines);
      gate.out.destination = getDestination(gate.out,lines);
      return gate;
   }
   function getDestination(source, lines) {
      let size = getInt();
      if (size < 0)
         inputError();
      if (size > 0 && lines === null)
         inputError();
      let des = new Vector();
      for (let i = 0; i < size; i++) {
         let linePos = getInt();
         if (linePos < 0 || linePos >= lines.length)
            inputError();
         des.addElement(lines[linePos]);
         lines[linePos].source = source;
      }
      return des;
   }
   function getSource(destination, lines)  {
      let linePos = getInt();
      if (linePos < 0)
         return null;
      if (lines === null || linePos >= lines.length)
         inputError();
      lines[linePos].destination = destination;
      return lines[linePos];
   }
   function getFloatRect() {
      return new FloatRect(getFloat(),getFloat(),getFloat(),getFloat());
   }
   function getFloat() {
      return getInt()/8192.0;
   }
   function getInt() {
      let n = 0;
      let neg = false;
      let ch = getNonBlank();
      if (ch === '-') {
         neg = true;
         ch = getChar();
      }
      if (ch < '0' || ch > '9')
         inputError();
      do {
         n = 10*n + ch.charCodeAt(0) - 48;
         ch = getChar();
      } while (ch >= '0' && ch <= '9');
      return (neg? -n : n);
   }
   function getChar() {
      if (pos >= text.length)
         inputError("Illegal data in file; unexpected end of file encountered.");
      return text[pos++];
   }
   function getNonBlank() {
      let ch;
      do {
         ch = getChar();
      } while (ch === ' ' || ch === '\r' || ch === '\n' || ch === '\t');
      return ch;
   }
   function getLine() {
      let buf = "";
      let ch;
      do {
         ch = getChar();
      } while (ch === '\n' || ch === '\r');
      do {
         buf += ch;
         ch = getChar();
      } while (ch !== '\n' && ch !== '\r');
      return buf.trim();
   }
}

function circuitsToText(circuitStack,scrollItems) {
   let text = ["This is an xLogicCircuits data file.","DO NOT EDIT THIS FILE!","File format version 1.0"]; // start with prolog
   let currentLine = "";
   putInt(circuitStack.length);
   println();
   for (let i = 0; i < circuitStack.length; i++) {
      let cir = circuitStack[i];
      if (i === 0) {
         putString('=');
         putCircuit(cir);
      }
      else {
         putString('@');
         putInt(cir.saveContainerWhileEnlarged.items.indexOf(cir));
         putFloatRect(cir.boundingBoxInContainer);
         println();
      }
   }
   putInt(scrollItems.length - 6);
   println();
   for (let i = 6; i < scrollItems.length; i++)
      putCircuit(scrollItems[i].item);
   return text.join("\n");
   function putCircuit(circuit) {
      putString(circuit.name);
      println();
      let itemCt = circuit.items.size();
      let lineCt = circuit.lines.size();
      let inputCt = circuit.inputs.size();
      let outputCt = circuit.outputs.size();
      putFloatRect(circuit.boundingBox);
      println();
      putFloatRect(circuit.savedBoundingBox === null ? circuit.boundingBox : circuit.savedBoundingBox);
      println();
      putString(itemCt + " " + lineCt + " " + inputCt + " " + outputCt);
      println();
      for (let i = 0; i < lineCt; i++)
         circuit.lines.elementAt(i).pos = i;
      for (let i = 0; i < inputCt; i++)
         putCircuitIONub(circuit.inputs.elementAt(i));
      for (let i = 0; i < outputCt; i++)
         putCircuitIONub(circuit.outputs.elementAt(i));
      for (let i = 0; i < itemCt; i++) {
         let item = circuit.items.elementAt(i);
         if (item instanceof Gate)
            putGate(item);
         else if (item instanceof Circuit) {
            putString('*');
            putCircuit(item);
         }
         else
            putTack(item);
      }
   }
   function putTack(tack) {
      putString('T');
      putInt(tack.connect_x);
      putInt(tack.connect_y);
      if (tack.source === null)
         putInt(-1);
      else
         putInt(tack.source.pos);
      putDestination(tack.destination);
      println();
   }
   function putCircuitIONub(nub) {
      if (nub.kind === IONub.OUTPUT)
         putString('>');
      else
         putString('<');
      putInt(nub.side);
      putFloat(nub.absolutePosition);
      if (nub.source === null)
         putInt(-1);
      else
         putInt(nub.source.pos);
      putDestination(nub.destination);
      println();
   }
   function putGate(gate) {
      if (gate.kind === Gate.NOTGATE)
         putString('N');
      else if (gate.kind === Gate.ORGATE)
         putString('R');
      else
         putString('A');
      putInt(gate.facing);
      putFloatRect(gate.boundingBox);
      if (gate.in1.source === null)
         putInt(-1);
      else
         putInt(gate.in1.source.pos);
      if (gate.kind !== Gate.NOTGATE) {
         if (gate.in1.source === null)
           putInt(-1);
         else
           putInt(gate.in2.source.pos);
      }
      putDestination(gate.out.destination);
      println();
   }
   function putDestination(destination) {
      putInt(destination.size());
      for (let i = 0; i < destination.size(); i++) {
         let line = destination.elementAt(i);
         putInt(line.pos);
      }         
   }
   function putFloatRect(r) {
      putFloat(r.x);
      putFloat(r.y);
      putFloat(r.width);
      putFloat(r.height);
   }
   function putFloat(x) {
      currentLine += Math.round(x*8192) + " ";
   }
   function putInt(x) {
      currentLine += Math.round(x) + " ";
   }
   function putString(s) {
      currentLine += s;
   }
   function println() {
      text.push(currentLine);
      currentLine = "";
   }
 }


function checkForExample() {
   let ex = window.location.search.match("^\\?file=([a-zA-Z0-9/.%_+-]+)");
   if (ex) {
      loadExample(decodeURIComponent(ex[1]));
   }
   async function loadExample(url) {
      let controller = new AbortController();
      loading = true;
      setMessage("Trying to load file of examples from '" + url + "'.  Please wait!");
      let timedout = false;
      setTimeout(function(){timedout = true; controller.abort();}, 5000);
      try {
          let response = await fetch(url, {signal: controller.signal});
          if (!response.ok)
             throw "HTTP error status " +  response.status;
          let text = await response.text();
          newCircuit(text,false);
          setMessage("Loaded examples from '" + url + "'.");
      }
      catch (e) {
          if (timedout)
              setMessage("Failed to load examples from '" + url + "' (Request timed out)");
          setMessage("Failed to load examples from '" + url + "' (" + 
              (e instanceof Error? e.message : e) + ")");
      }
      finally {
          loading = false;
          setEnabledStates();
      }
   }
}

//------ Undo and Redo ----------------------------------------------

function addUndoItem(item) {
   if (redoStartIndex < undoItems.length)
      undoItems.splice(redoStartIndex, UNDO_MAX);
   if (undoItems.length > UNDO_MAX)
      undoItems.shift();
   undoItems.push(item);
   redoStartIndex = undoItems.length;
   undoBtn.innerHTML = "Undo " + item.name;
   undoBtn.disabled = false;
   redoBtn.innerHTML = "Redo";
   redoBtn.disabled = true;
}
function doUndo() {
   setMessage();
   if (redoStartIndex === 0)
      return;
   redoStartIndex--;
   applyUndo(undoItems[redoStartIndex]);
   if (redoStartIndex === 0) {
       undoBtn.disabled = true;
       undoBtn.innerHTML = "Undo";
   }
   else {
       undoBtn.innerHTML = "Undo " + undoItems[redoStartIndex-1].name;
   }
   redoBtn.innerHTML = "Redo " + undoItems[redoStartIndex].name;
   redoBtn.disabled = false;
}
function doRedo() { 
   setMessage();
   if (redoStartIndex >= undoItems.length)
      return;
   applyRedo(undoItems[redoStartIndex]);
   redoStartIndex++;
   if (redoStartIndex === undoItems.length) {
      redoBtn.disabled = true;
      redoBtn.innerHTML = "Redo";
   }
   else {
      redoBtn.innerHTML = "Redo " + undoItems[redoStartIndex].name;
   }
   undoBtn.innerHTML = "Undo " + undoItems[redoStartIndex-1].name;
   undoBtn.disabled = false;
}

function applyUndo(undo) {
   if (loading)
      return;
   selectItem(null);
   switch(undo.name) {
   case "Delete":
      undo.item.unDelete(undo.owner);
      selectItem(undo.item);
      break;
   case "Delete Scroll Icon":
      if (undo.position === scrollItems.length)
         scroller.appendChild(undo.item.canvas);
      else
         scroller.insertBefore(undo.item.canvas,scrollItems[undo.position].canvas);
      scrollItems.splice(undo.position,0,undo.item);
      selectItem(undo.item.item,true);
      break;
   case "Clear":
      circuitStack = [undo.circuit];
      currentCircuit = undo.circuit;
      currentCircuitIndex = 0;
      titleInput.value = undo.title;
      break;
   case "Clear Subcircuit":
      currentCircuit.items = undo.items;
      currentCircuit.lines = undo.lines;
      for (let i = 0; i < currentCircuit.lines.size(); i++) {
         let it = currentCircuit.lines.elementAt(i);
         it.destination.source = it;
         it.source.destination.addElement(it);
      }
      titleInput.value = undo.title;
      break;
   case "New":
      titleInput.value = undo.oldtitle;
      circuitStack = undo.stack;
      currentCircuitIndex = circuitStack.length - 1;
      currentCircuit = circuitStack[currentCircuitIndex];
      for (let i = 0; i < undo.scrollitems.length; i++) {
         scroller.appendChild(undo.scrollitems[i].canvas);
         scrollItems.push(undo.scrollitems[i]);
      }
      break;
   case "Resize":
      undo.item.reshape(undo.startbox[0], undo.startbox[1], undo.startbox[2], undo.startbox[3]);
      selectItem(undo.item);
      break;
   case "Add Item":
   case "Add Wire":
      undo.item.delete(undo.container);
      break;
   case "Move Item":
      undo.item.dragTo(undo.startPosition[0],undo.startPosition[1],undo.bounds);
      selectItem(undo.item);
      break;
   case "Insert Tack in Wire":
      undo.tack.delete(undo.container);
      undo.line.unDelete(undo.container);
      selectItem(undo.line);
      break;
   case "Drop Tack":
      undo.tack.delete(undo.container);
      break;
   case "Shrink Circuit":
      undo.item.deiconify(0,0,canvas.width,canvas.height,currentCircuit);
      circuitStack.push(undo.item);
      currentCircuit = undo.item;
      currentCircuitIndex = circuitStack.length-1;
      break;
   case "Enlarge Subcircuit":
      let r = undo.item.boundingBoxInContainer;
      undo.item.iconify(r.x,r.y,r.width,r.height);
      circuitStack.pop();
      currentCircuitIndex = circuitStack.length-1;
      currentCircuit = circuitStack[currentCircuitIndex];
      selectItem(undo.item);
      break;
   case "Iconify":
      scrollItems.pop();
      scroller.removeChild(undo.scrollitem.canvas);
      circuitStack = [undo.scrollitem.item];
      currentCircuit = undo.scrollitem.item;
      currentCircuitIndex = 0;
      currentCircuit.deiconify(0,0,canvas.width,canvas.height);
      titleInput.value = currentCircuit.name;
      break;
   case "Deiconify":
      if (undo.position === scrollItems.length)
         scroller.appendChild(undo.oldscrollitem.canvas);
      else
         scroller.insertBefore(undo.oldscrollitem.canvas,scrollItems[undo.position].canvas);
      scrollItems.splice(undo.position,0,undo.oldscrollitem);
      undo.oldscrollitem.item.iconify(20,10,70,80);
      if (undo.newscrollitem === null) {
         currentStack = undo.oldstack;
         currentCircuitIndex = currentStack.length-1;
         currentCircuit = currentStack[currentCircuitIndex];
         titleInput.value = undo.oldtitle;
      }
      else {
         scrollItems.pop();
         scroller.removeChild(undo.newscrollitem.canvas);
         circuitStack = undo.oldstack;
         currentCircuitIndex = circuitStack.length-1;
         currentCircuit = circuitStack[currentCircuitIndex];
         circuitStack[0].deiconify(0,0,canvas.width,canvas.height);
         for (let i = 1; i < circuitStack.length; i++)
            circuitStack[i].deiconify(0,0,canvas.width,canvas.height,circuitStack[i-1]);
         titleInput.value = currentCircuit.name;
      }
      selectItem(undo.oldscrollitem.item,true);
      break;
   case "Load Local File":
      scrollItems.splice(6,10000);
      for (let i = undo.newscrollitems.length-1; i >= 0; i--)
         scroller.removeChild(undo.newscrollitems[i].canvas);
      for (let i = 0; i < undo.removedscrollitems.length; i++) {
         scrollItems.push(undo.removedscrollitems[i]);
         scroller.appendChild(undo.removedscrollitems[i].canvas);
      }
      circuitStack = undo.oldstack;
      currentCircuitIndex = circuitStack.length-1;
      currentCircuit = circuitStack[currentCircuitIndex];
      titleInput.value = undo.oldtitle;
      break;
   default:
      alert("Unknown undo item: " + undo.name);
   }
   drawCurrentCircuit();
   setEnabledStates();
}

function applyRedo(redo) {
   if (loading)
      return;
   selectItem(null);
   switch(redo.name) {
   case "Delete":
      redo.item.selected = false;
      redo.item.delete(redo.owner);
      break;
   case "Delete Scroll Icon":
      scroller.removeChild(redo.item.canvas);
      scrollItems.splice(redo.position,1);
      break;
   case "Clear":
      circuitStack = redo.newstack;
      currentCircuit = circuitStack[0];
      currentCircuitIndex = 0;
      titleInput.value = redo.title;
      break;
   case "Clear Subcircuit":
      for (let i = 0; i < currentCircuit.inputs.size(); i++) {
         currentCircuit.inputs.elementAt(i).destination = new Vector();
      }
      for (let i = 0; i < currentCircuit.outputs.size(); i++) {
         currentCircuit.outputs.elementAt(i).source = null;
      }
      currentCircuit.items = new Vector();
      currentCircuit.lines = new Vector();
      titleInput.value = redo.title;
      break;
   case "New":
      titleInput.value = redo.newtitle;
      circuitStack = redo.newstack;
      currentCircuit = circuitStack[0];
      currentCircuitIndex = 0;
      for (let i = redo.scrollitems.length-1; i >= 0; i--)
          scroller.removeChild(redo.scrollitems[i].canvas);
      scrollItems.splice(6,10000);
      scroller.scrollTop = 0;
      break;
   case "Resize":
      redo.item.reshape(redo.endbox[0], redo.endbox[1], redo.endbox[2], redo.endbox[3]);
      selectItem(redo.item);
      break;
   case "Add Item":
   case "Add Wire":
      redo.item.unDelete(redo.container);
      selectItem(redo.item);
      break;
   case "Move Item":
      redo.item.dragTo(redo.endPosition[0],redo.endPosition[1], redo.bounds);
      selectItem(redo.item);
      break;
   case "Insert Tack in Wire":
      redo.line.delete(redo.container);
      redo.tack.unDelete(redo.container);
      selectItem(redo.tack);
      break;
   case "Drop Tack":
      redo.tack.unDelete(redo.container);
      selectItem(redo.tack);
      break;
   case "Shrink Circuit":
      let r = redo.item.boundingBoxInContainer;
      redo.item.iconify(r.x, r.y, r.width, r.height);
      circuitStack.pop();
      currentCircuitIndex = circuitStack.length-1;
      currentCircuit = circuitStack[currentCircuitIndex];
      selectItem(redo.item);
      titleInput.value = currentCircuit.name;
      break;
   case "Enlarge Subcircuit":
      redo.item.deiconify(0,0,canvas.width,canvas.height,currentCircuit);
      circuitStack.push(redo.item);
      currentCircuitIndex = circuitStack.length-1;
      currentCircuit = circuitStack[currentCircuitIndex];
      titleInput.value = currentCircuit.name;
      break;
   case "Iconify":
      scrollItems.push(redo.scrollitem);
      scroller.appendChild(redo.scrollitem.canvas);
      redo.scrollitem.item.iconify(20,10,70,80);
      circuitStack = redo.newstack;
      currentCircuitIndex = circuitStack.length-1;
      currentCircuit = circuitStack[currentCircuitIndex];
      selectItem(redo.scrollitem.item,true);
      titleInput.value = redo.newtitle;
      break;
   case "Deiconify":
      scrollItems.splice(redo.position,1);
      scroller.removeChild(redo.oldscrollitem.canvas);
      currentCircuit = redo.oldscrollitem.item;
      circuitStack = [currentCircuit];
      currentCircuitIndex = 0;
      currentCircuit.deiconify(0,0,canvas.width,canvas.height);
      titleInput.value = currentCircuit.name;
      if (redo.newscrollitem !== null) {
          for (let i = redo.oldstack.length-1; i > 0; i--) {
            let r = redo.oldstack[i].boundingBoxInContainer.getIntRect();
            redo.oldstack[i].iconify(r.x,r.y,r.width,r.height);
          }
          redo.oldstack[0].iconify(20,10,70,80);
          scrollItems.push(redo.newscrollitem);
          scroller.appendChild(redo.newscrollitem.canvas);
      }
      break;
   case "Load Local File":
      scrollItems.splice(6,10000);
      for (let i = redo.removedscrollitems.length-1; i >= 0; i--)
         scroller.removeChild(redo.removedscrollitems[i].canvas);
      for (let i = 0; i < redo.newscrollitems.length; i++) {
         scrollItems.push(redo.newscrollitems[i]);
         scroller.appendChild(redo.newscrollitems[i].canvas);
      }
      circuitStack = redo.newstack;
      currentCircuitIndex = circuitStack.length-1;
      currentCircuit = circuitStack[currentCircuitIndex];
      titleInput.value = currentCircuit.name;
      break;
   default:
      alert("Unknown redo item: " + redo.name);
   }
   drawCurrentCircuit();
   setEnabledStates();
}

//--------------------------------------------------------------
function init() {
    try {
        canvas = document.getElementById("circuit");
        graphics = canvas.getContext("2d");
        OSC = document.getElementById("overlay");
        OSG = OSC.getContext("2d");
        graphics.lineWidth = 2;
        OSG.lineWidth = 2;
        graphics.lineCap = "round";
    } catch(e) {
        document.getElementById("canvasholder").innerHTML =
           "<p>Canvas graphics is not supported.<br>" +
           "An error occurred while initializing graphics.</p>";
        return;
    }
    adjustToWindowSize();
    window.addEventListener("resize",adjustToWindowSize,false);
    scroller = document.getElementById("scroller");
    message = document.getElementById("message");
    scrollItems = [
        new ScrollItem( new Gate(Gate.NOTGATE, Gate.FACERIGHT), "NOT Gate", Gate.NOTGATE ),
        new ScrollItem( new Gate(Gate.ANDGATE, Gate.FACERIGHT), "AND Gate", Gate.ANDGATE ),
        new ScrollItem( new Gate(Gate.ORGATE, Gate.FACERIGHT), "OR Gate", Gate.ORGATE ),
        new ScrollItem( new CircuitIONub(CircuitIONub.ONLEFT,0,true), "INPUT", 3 ),
        new ScrollItem( new CircuitIONub(CircuitIONub.ONLEFT,0,false), "OUTPUT", 4 ),
        new ScrollItem( new Tack(), '"TACK"', 5 )
    ];
    canvas.onmousedown = doMouseOnCircuit;
    canvas.ondblclick = doDoubleClick;
    loadBtn = document.getElementById("loadbtn");
    saveBtn = document.getElementById("savebtn");
    newBtn = document.getElementById("newbtn");
    newBtn.onclick = doNew;
    clearBtn = document.getElementById("clearbtn");
    clearBtn.onclick = doClear;
    deleteBtn = document.getElementById("deletebtn");
    deleteBtn.onclick = doDelete;
    undoBtn = document.getElementById("undobtn");
    undoBtn.onclick = doUndo;
    undoBtn.disabled = true;
    redoBtn = document.getElementById("redobtn");
    redoBtn.onclick = doRedo;
    redoBtn.disabled = true;
    iconifyBtn = document.getElementById("iconifybtn");
    iconifyBtn.onclick = doIconify;
    deiconifyBtn = document.getElementById("deiconifybtn");
    deiconifyBtn.onclick = doDeiconify;
    enlargeBtn = document.getElementById("enlargebtn");
    enlargeBtn.onclick = doEnlarge;
    shrinkBtn = document.getElementById("shrinkbtn");
    shrinkBtn.onclick = doShrink;
    document.getElementById("powercheck").onchange = doPower;
    document.getElementById("powercheck").checked = false;
    document.getElementById("speedselect").onchange = doSpeed;
    document.getElementById("speedselect").value = "0";
    setUpFileHandling();
    scroller.scrollTop = 0;
    titleInput = document.getElementById("title");
    titleInput.value = "Untitled " + (++untitledCt);
    currentCircuit = new Circuit();
    circuitStack = [currentCircuit];
    currentCircuitIndex = 0;
    setEnabledStates();
    drawCurrentCircuit();
    checkForExample();
}

window.onload = init;
</script>
</head>
<body>
<div id="content">


<p style="border-bottom: 1.5pt solid black; white-space:pre; margin-top:0; margin-bottom: 0"><span style="font-size:200%; font-weight:bold;margin: 5pt 0 5pt 0;">xLogicCircuits</span><span style="margin-left: 50pt"><b>Click for: <a href="info.html">information and instructions</a>.</b></span></p>


<noscript><p>JavaScript is not available.  It is required to use this page!</p></noscript>

<table border=0 cellspacing=0 cellpadding=4>
<tr><td colspan=3><span id="message" style="font-weight:bold; color: #BB0000">&nbsp;</span></td></tr>
<tr>
   <td>
     <button id="newbtn" title="Delete everything and start from scratch.">New</button>
     <button id="loadbtn" title="Load a local file. (One some browsers, this will look like selecting a file for upload.)">Load</button>
     <button id="savebtn" title="Save current circuit to a local file.  (On some browsers, this can look like a standard file download.)">Save</button>
     <label style="margin-left:20px" title="Turns power on and off.  While power is on, clicking a circuit input will turn it on and off."><input type="checkbox" id="powercheck">Power</label>
     <select id="speedselect" style="margin-left:20px" title="Controls how fast on/off values propagate through the circuit.  Only applies when power is on.">
        <option value="0">Fast Speed</option>
        <option value="1">Moderate Speed</option>
        <option value="2">Slow Speed</option>
     </select>
   </td>
   <td><button id="shrinkbtn" style="margin-left:30px" title="If you are viewing a subcircuit that has been enlarged from the circuit that contains it, this will shrink the subcircuit back down and display its container instead.">Shrink</button> 
       <button id="enlargebtn" title="If the currently selected item is a subcircuit in the current circuit, this will this will let you view and edit that subcircuit.  You can also double-click the subcircuit to enlarge it.">Enlarge</button></td>
   <td><button id="undobtn" style="margin-left:30px" title="Undo your most recent action.">Undo</button></td>
</tr>
<tr>
   <td>
     <span>Title:&nbsp;<input type="text" id="title" size="15"></span>
     <button id="deletebtn" style="margin-left:40px" title="Delete the currenty selected item.">Delete</button>
     <button id="clearbtn" title="Delete contents of the circuit that is currently displayed.  If the current circuit is a subcircuit, only gates, tacks, and wires are deleted, but not inputs and outputs.">Clear</button>
   </td>
   <td><button id="iconifybtn" style="margin-left:30px" title="Make the current circuit into an icon in the scroller, which can then be added as a subcircuit to another circuit.">Iconify</button>
       <button id="deiconifybtn" title="If the currently selected item is an iconified circuit that has been added to the scroller, this will show that circuit.  If the current circuit was not empty, it will be iconified and added to the scroller.  You can also deiconify by double-clicking the icon.">Deiconify</button></td>
   <td><button id="redobtn" style="margin-left:30px" title="Redo the action that was most recently undone.">Redo</button></td>
</tr>
</table>


<table border=0 cellspacing=0 cellpadding=0>
<tr valign=top>
    <td><div id="scroller"></div></td>
    <td><div id="canvasholder"><canvas id="circuit" width=700 height=500></canvas></div></td>
</tr>
</table>

</div>

<canvas id="overlay" width=802 height=500></canvas>

</body>
</html>
